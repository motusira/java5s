interface A {
    default void greet() {
        System.out.println("Привет от A");
    }
}

interface B {
    default void greet() {
        System.out.println("Привет от B");
    }
}

// Класс, реализующий оба интерфейса
class C implements A, B {
    // Компилятор требует явного разрешения конфликта:
    @Override
    public void greet() {
        // Варианты решения:
        // 1. Своя реализация:
        System.out.println("Привет от C");

        // 2. Или вызов конкретной реализации через super:
        // A.super.greet();  // вызов default-метода из A
        // B.super.greet();  // вызов default-метода из B
    }
}

public class DiamondProblemDemo {
    public static void main(String[] args) {
        C obj = new C();
        obj.greet(); // вызывает реализацию из класса C
    }
}

/*
Объяснение Практики #2:

Если класс реализует два интерфейса, содержащих default-методы с одинаковой сигнатурой,
возникает неоднозначность (проблема ромбовидного наследования).
Компилятор не может решить, какую реализацию использовать, и выдаёт ошибку.

Чтобы устранить ошибку, класс обязан:
- либо переопределить метод и предоставить свою реализацию,
- либо явно вызвать нужную реализацию с помощью InterfaceName.super.method().

Это позволяет сохранить безопасность и предсказуемость поведения при множественном наследовании
поведения (но не состояния), что и было целью введения default-методов в Java 8.
*/
